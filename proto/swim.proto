// Copyright (c) 2016 AlertAvert.com.  All rights reserved.
// Licensed under the Apache 2 License terms.

// These are the messages that define an implemenation of the SWIM protocol.
//
// See [References](https://github.com/massenz/distlib#swim-gossip-and-consensus-algorithm)
// in the README doc.
package swim;


// A running SWIM service is uniquely identified by the hostname:port combination.
// The optional IP address is only provided to help in those deployment where DNS
// resolution is either not available, feasible or too expensive computationally.
message Server {
    required string hostname = 1;
    required int32 port = 2;
    optional string ip_addr = 3;
}


// Unless otherwise stated (for example, when this message is part of the `dead` list in a
// `SwimReport` message) this assumes that the `server` is alive and well.
message SwimStatus {
    required Server server = 1;

    // UTC-based UNIX time (seconds from epoch, 1/1/1970) of when this
    // message was created and can be reasonably assumed (but not guaranteed)
    // that it also represents the time at which the `server` state was
    // accurately described by `state`.
    required fixed64 timestamp = 2;

    // If the status is sent on behalf of another server,
    // the forwarder should enter its identity here.
    optional Server forwarder = 3;
}

// A status report disseminated "infection-style" via the SWIM protocol, reporting
// changes in the nodes' population status: the reporter will list newly detected (since last
// report) `suspected` and `dead` nodes, as well as `alive` nodes (formerly "suspected" of being
// dead).
//
// The report here may not contain the full list, as in the SWIM protocol, to ensure
// constant-size messages and reduce network congestion as clusters' size grows, the size of the
// report is capped at a given max amount of servers' statuses.
message SwimReport {
    required Server sender = 1;

    // UTC-based UNIX time (seconds from epoch, 1/1/1970) of when this
    // message was created and can be reasonably assumed (but not guaranteed)
    // that it also represents the time at which the `server` state was
    // accurately described by `state`.
    required fixed64 timestamp = 2;

    // Each of these lists can be empty, but at least one of them SHOULD contain at
    // least one element.
    // Collectively, they will contain no more than MAX_REPORTED servers, as configured in the
    // system.
    //
    // `alive` servers are those that were `suspected` to have crashed, but have subsequently
    // been found to be healthy and responding, within the configured `SUSPECTED_TTL` time.
    repeated SwimStatus alive = 3;

    // These servers are suspected to have crashed (have not responded to pings recently) but
    // still within the grace period (`SUSPECTED_TTL` seconds) before they are declared to
    // be `dead`.
    repeated SwimStatus suspected = 4;

    // Finally, after enough time has elapsed without a response, these server are placed in
    // this list, from which they will never be taken out.
    //
    // TODO: revisit the "faulty detectors" paper and reconsider whether "revive" servers.
    repeated SwimStatus dead = 5;
}


// Simple status message exchanged between servers participating in
// the SWIM protocol.
//
// For more details, see: https://goo.gl/VUn4iQ
message SwimEnvelope {
    enum Type {
        // An UPDATE is sent by a "suspected" server to its (randomly chosen) neighbors
        // to confirm its `alive` status.  It is also used by servers during the "detection"
        // phase, to 'ping' their neighbors and discover their state.
        //
        // No payload is sent with this message.
        STATUS_UPDATE = 1;

        // This is used by servers to exchange status updates on the clusters.
        // The sole payload is the `report` message.
        STATUS_REPORT = 2;

        // Used by servers to request other nodes to ping the given `destination_server` on
        // their behalf; more info in the SWIM protocol document.
        // The sole payload is the `destination_server` message.
        STATUS_REQUEST = 3;
    }

    // What type of message content will be enclosed in the "envelope"; receiving servers are
    // free to simply ignore malformed messages or return error responses.
    required Type type = 1;

    // The server sending this envelope, which will also be assumed to be "healthy" by the
    // receiver who will update its membership list accordingly.
    required Server sender = 2;

    // The local clock of the `sender`, not necessarily related in any temporal relationship
    // with the receiving server (but potentially useful in a 'Vector Clock' scheme).
    required fixed64 timestamp = 3;

    optional SwimReport report = 5;
    optional Server destination_server = 6;
}
